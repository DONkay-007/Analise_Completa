# TODAS AS IMPORTA√á√îES USADAS AT√à O MOMENTO
import streamlit as st
import pandas as pd
import numpy as np
from io import BytesIO
import time
import xlsxwriter
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import plotly.express as px
import matplotlib.pyplot as plt
import os
import requests
import json
from pathlib import Path
from datetime import datetime
import webbrowser
from ydata_profiling import ProfileReport

# ==========================
# Carregar dados
# ==========================

# Caminho do CSV
csv_path = "data/banco_agro_projeto_limpo.csv"
# ---------- VERIFICA√á√ÉO DO CSV ----------
if os.path.exists(csv_path) and os.path.getsize(csv_path) > 0:
    df = pd.read_csv(csv_path)
else:
    st.error("‚ùå O arquivo CSV n√£o foi encontrado ou est√° vazio. Verifique o caminho e os dados.")
    st.stop()  # interrompe o app se n√£o houver CSV


# Padronizar nomes de colunas
df.columns = [c.strip() for c in df.columns]

# Converter para datetime mantendo suporte ao .dt
df["Data_de_vendas"] = pd.to_datetime(df["Data_de_vendas"])

# Salvar normalizado
df.to_csv("data/banco_agro_projeto_limpo.csv", index=False)

# ==========================
# Fun√ß√µes auxiliares
# ==========================
def format_number(value, prefix=''):
    for unit in ['', 'mil']:
        if value < 1000:
            return f'{prefix} {value:.2f} {unit}'
        value /= 1000
    return f'{prefix} {value:.2f} milh√µes'

def convert_excel(df):
    output = BytesIO()
    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
        df.to_excel(writer, index=False, sheet_name="Dados")
    return output.getvalue()

def mensagem_sucesso():
    sucess = st.success('‚úÖ Arquivo baixado com sucesso!')
    sucess.empty()

# ==========================
# Configura√ß√£o da p√°gina
# ==========================
st.set_page_config(layout="wide")
st.title("üìä DASHBOARD AGRO üêÇ")

# Criar abas
aba1, aba2, aba3, aba4, aba5, aba6= st.tabs(['üìÇ Dataset', 'üìà Insights', 'ü§ñ Chatbot', 'üß† ML','üìãüìå Realat√≥rio','üìö Sobre'])

# ==========================
# Tab 1: Dataset
# ==========================
with aba1:
    with st.container():
        st.subheader("üìä Visualiza√ß√£o do Dataset")

    # -----------------------------
    # FILTROS
    filtro_cidade = st.sidebar.multiselect(
        "üèôÔ∏è Cidade",
        options=df["cidade"].unique(),
        default=[]
    )
    filtro_vendedor = st.sidebar.multiselect(
        "üßë‚Äçüíº Vendedor",
        options=df["Vendedor"].unique(),
        default=[]
    )
    with st.sidebar.expander('üìÖ Data da Compra'):
        data_compra = st.date_input(
            "Selecione o intervalo de datas",
            (df['Data_de_vendas'].min().date(), df['Data_de_vendas'].max().date())
        )

    # Aplicar filtros
    filtered_df = df.copy()
    if filtro_cidade:
        filtered_df = filtered_df[filtered_df["cidade"].isin(filtro_cidade)]
    if filtro_vendedor:
        filtered_df = filtered_df[filtered_df["Vendedor"].isin(filtro_vendedor)]
    if data_compra:
        inicio, fim = data_compra
        filtered_df = filtered_df[
            (filtered_df["Data_de_vendas"].dt.date >= inicio) &
            (filtered_df["Data_de_vendas"].dt.date <= fim)
        ]

    # Mostrar dados
    st.dataframe(filtered_df, use_container_width=True)
    st.markdown(f"**üìå Total de registros exibidos:** {len(filtered_df)}")

    # -----------------------------
    # DOWNLOAD
    coluna1, coluna2 = st.columns([3, 1])
    with coluna1:
        nome_arquivo = st.text_input('Digite o nome do arquivo (sem extens√£o):', key='nome_arquivo').strip()
    if not nome_arquivo:
        nome_arquivo = 'relatorio'
    if not nome_arquivo.lower().endswith('.xlsx'):
        nome_arquivo += '.xlsx'

    with coluna2:
        st.download_button(
            '‚¨áÔ∏è Baixar Excel',
            data=convert_excel(filtered_df),
            file_name=nome_arquivo,
            mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            on_click=mensagem_sucesso
        )






# ==========================
# Tab 2: Insights
# ==========================
with aba2:
    st.subheader("üìä An√°lises de Vendas")    
    coluna1, coluna2 = st.columns(2)

    # ---- Gr√°fico 1
    with coluna1:
        st.markdown("#### üìÖ Faturamento por Total")
        df['Faturamento'] = df['Vendidos'] * df['Preco_kg']
        faturamento_total = df.groupby('Produto')['Faturamento'].sum().reset_index().round().sort_values(by="Faturamento", ascending=False)
        st.markdown(f"### |üí∞ Faturamento Total: **R$ {faturamento_total['Faturamento'].sum():,.2f}**|")
        
        
        st.markdown("#### üåÜ Faturamento por Cidade")
        df_cidade = df.groupby("cidade", as_index=False).agg({
            "Faturamento": "sum",   
            "Vendidos": "sum",      
            "latitude": "first",    
            "longitude": "first"    
        })
        fig = px.scatter_mapbox(
            df_cidade,
            lat="latitude",
            lon="longitude",
            size="Faturamento",
            color="Faturamento",
            hover_name="cidade",
            hover_data=["Vendidos", "Faturamento"],
            size_max=30,
            zoom=4
        )
        fig.update_layout(mapbox_style="carto-darkmatter", margin={"r":0,"t":0,"l":0,"b":0})
        st.plotly_chart(fig, use_container_width=True)

    # ---- Gr√°fico 2
    with coluna2:
        st.markdown("#### Perdas (N√£o vendidos)")
        df["N√£o_vendidos"] = df['Estoque'] * df["Preco_kg"]
        Perdas = df.groupby('Produto')['N√£o_vendidos'].sum().round(2).reset_index().sort_values(by="N√£o_vendidos",ascending=False)
        st.markdown(f"### |üí∏ Perdas Totais: **R$ {Perdas['N√£o_vendidos'].sum():,.2f}**|")
        
        
        st.markdown("#### üßë‚Äçüíº Faturamento por Vendedor")
        df_vendedor = df.groupby("Vendedor", as_index=False).agg({
            "Faturamento": "sum",    
            "Vendidos": "sum",      
            "latitude": "first",    
            "longitude": "first"  
        })
        fig = px.scatter_mapbox(
            df_vendedor,
            lat="latitude",
            lon="longitude",
            size="Faturamento",
            color="Faturamento",
            hover_name="Vendedor",
            hover_data=["Vendidos", "Faturamento"],
            size_max=30,
            zoom=4
        )
        fig.update_layout(mapbox_style="carto-darkmatter", margin={"r":0,"t":0,"l":0,"b":0})
        st.plotly_chart(fig, use_container_width=True)
        
    st.markdown("---")
    
    # Colunas lado a lado: pizza e linha
    col3, col4 = st.columns(2)

   # ---- Gr√°fico 3: Pizza interativa (Plotly)
with col3:
    st.markdown("#### üë®‚Äçüíº Rendimento de Funcion√°rio")
    sales_maior = df.groupby('Vendedor')['Vendidos'].sum().reset_index().sort_values(by='Vendidos', ascending=False)

    fig_pizza = px.pie(
        sales_maior,
        names='Vendedor',
        values='Vendidos',
        color='Vendedor',
        color_discrete_sequence=px.colors.sequential.Viridis,
        hole=0.35,
    )
    fig_pizza.update_traces(
        textinfo='percent+label',
        pull=[0.05]*len(sales_maior),
        textfont_size=12
    )
    fig_pizza.update_layout(
        title=dict(text="üçï Total Vendido por Vendedor", x=0.5, font=dict(size=18, color='#00c7c7')),
        paper_bgcolor='#0e1117',
        plot_bgcolor='#1e2130',
        font=dict(color='white', family="Arial"),
        height=400,
        margin=dict(t=60, b=20, l=0, r=0)
    )
    st.plotly_chart(fig_pizza, use_container_width=True)


# ---- Gr√°fico 4: Linhas interativas (Plotly)
with col4:
    st.markdown("#### üìà Vendas Mensais por Ano (2024‚Äì2029)")

    df['Data_de_vendas'] = pd.to_datetime(df['Data_de_vendas'], errors='coerce')
    df_filtrado = df[df['Data_de_vendas'].dt.year.isin([2024, 2025, 2026, 2027, 2028, 2029])]
    df_filtrado['Ano'] = df_filtrado['Data_de_vendas'].dt.year
    df_filtrado['Mes'] = df_filtrado['Data_de_vendas'].dt.month
    vendas_mensais = df_filtrado.groupby(['Ano', 'Mes'], as_index=False)['Vendidos'].sum()

    fig_linha = px.line(
        vendas_mensais,
        x='Mes',
        y='Vendidos',
        color='Ano',
        markers=True,
        color_discrete_sequence=px.colors.sequential.Plasma
    )
    fig_linha.update_layout(
        title=dict(text="üìä Evolu√ß√£o de Vendas por M√™s", x=0.5, font=dict(size=18, color='#00c7c7')),
        xaxis=dict(
            tickmode='array',
            tickvals=list(range(1, 13)),
            ticktext=['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
            title='M√™s',
            showgrid=True,
            gridcolor='rgba(255,255,255,0.1)'
        ),
        yaxis=dict(title='Total Vendido', showgrid=True, gridcolor='rgba(255,255,255,0.1)'),
        paper_bgcolor='#0e1117',
        plot_bgcolor='#1e2130',
        font=dict(color='white'),
        legend=dict(title='Ano', orientation='h', y=-0.2, x=0.5, xanchor='center'),
        height=400,
        margin=dict(t=60, b=50, l=40, r=20)
    )
    st.plotly_chart(fig_linha, use_container_width=True)
    st.markdown("---")
    
    def gerar_metricas():
        produto_mais = df['Produto'].mode()[0]
        yield f"üì¶ Produto mais vendido: **{produto_mais}**\n"
        time.sleep(0.5)

        media_estoque = df['Estoque'].mean()
        yield f"üìä M√©dia de itens em estoque: **{media_estoque:.0f}**\n"
        time.sleep(0.5)

        media_vendas = df['Vendidos'].mean()
        yield f"üõí M√©dia de vendas: **{media_vendas:.0f}**\n"
        time.sleep(0.5)

        dispersao = df['Vendidos'].std() / df['Vendidos'].mean() * 100
        yield f"üìâ Dispers√£o relativa das vendas: **{dispersao:.2f}%**\n"
        time.sleep(0.5)

        desvio = df['Vendidos'].std()
        yield f"üìè Desvio padr√£o das vendas: **{desvio:.0f}**\n"
        time.sleep(0.5)

        variancia = df['Vendidos'].var()
        yield f"üîé Vari√¢ncia das vendas: **{variancia:.0f}**\n"
        time.sleep(0.5)

        faturamento_ano = df.groupby(df['Data_de_vendas'].dt.year)['Vendidos'].sum().reset_index()
        faturamento_ano.columns = ["Ano", "Total Vendido"]
        yield "üìÜ Vendas totais por ano: \n"
        yield faturamento_ano.to_string(index=False)
        time.sleep(0.5)

        faturamento_cidade = df.groupby("cidade")['Vendidos'].sum().reset_index()
        faturamento_cidade.columns = ["Cidade", "Total Vendido"]
        yield "üèô Vendas totais por cidade:\n"
        yield faturamento_cidade.to_string(index=False)
        time.sleep(0.5)

    if st.button("üöÄ Gerar M√©tricas"):
        st.write_stream(gerar_metricas)
        st.markdown("---")
        st.success("‚úÖ M√©tricas geradas com sucesso!")
        
        
        
        
# ==========================
# Tab 3: Chatbot PROJETO AGRO
# ==========================

# URL do webhook (ajuste se necess√°rio)
N8N_WEBHOOK_URL = "http://10.0.0.144:5678/webhook/chat-vendas"
with aba3:
    # ======= Estilo CSS =======
    st.markdown(
        """
        <style>
        .chat-container {
            background-color: #1e1e2f;
            color: white;
            padding: 20px;
            border-radius: 12px;
        }
        .chat-message { padding: 10px 14px; border-radius: 12px; margin-bottom: 10px; max-width:85%; font-size:14px;}
        .chat-user { background-color: #2e6fe2; color: white; margin-left:auto; }
        .chat-bot { background-color: #323449; color: #f1f1f1; margin-right:auto; }
        </style>
        """,
        unsafe_allow_html=True,
    )

    st.title("ü§ñ Chatbot PROJETO AGRO")
    st.caption("Converse com seus dados agr√≠colas de forma inteligente üå±")
    st.divider()
    st.markdown("### üìÇ Envie ou selecione sua base de dados (CSV)")

    # Upload opcional do CSV
    uploaded_file = st.file_uploader("Envie o arquivo CSV com seus dados", type="csv")

    def ask_chatbot(question, uploaded_file=None):
        """
            Envia uma pergunta e um arquivo CSV (opcional) para o chatbot n8n e retorna a resposta.
        """
        try:
            csv_text = None

            # 1. Prioriza o arquivo enviado pelo usu√°rio
            if uploaded_file is not None:
                raw_data = uploaded_file.getvalue()
                try:
                    # Tenta decodificar com UTF-8, o padr√£o mais comum
                    csv_text = raw_data.decode("utf-8")
                except UnicodeDecodeError:
                    # Se falhar, tenta com latin-1, comum em arquivos do Excel no Windows
                    print("Decodifica√ß√£o com UTF-8 falhou, tentando com latin-1.")
                    csv_text = raw_data.decode("latin-1", errors="replace")
            else:
                # 2. Se nenhum arquivo for enviado, procura por um arquivo local padr√£o
                possible_paths = [
                    Path("C:/n8n-ffmpeg/data/banco_agro_projeto_limpo.csv"), # Caminho Windows
                    Path("/data/banco_agro_projeto_limpo.csv"),             # Caminho Linux/Docker
                    Path("banco_agro_projeto_limpo.csv"),                   # Caminho relativo
                ]
                for p in possible_paths:
                    if p.exists():
                        print(f"Arquivo local encontrado em: {p}")
                        csv_text = p.read_text(encoding="utf-8", errors="replace")
                        break

            # Se, ap√≥s todas as tentativas, nenhum CSV foi encontrado, retorna um erro
            if not csv_text:
                return "‚ö†Ô∏è Nenhum arquivo CSV encontrado. Por favor, envie um arquivo para continuar."

            # 3. Envia a requisi√ß√£o para o n8n
            payload = {"mensagem": question, "csv": csv_text}
            headers = {"Content-Type": "application/json"}

            resp = requests.post(N8N_WEBHOOK_URL, json=payload, headers=headers, timeout=60) # Timeout aumentado para 60s
            resp.raise_for_status() # Lan√ßa um erro para respostas HTTP 4xx/5xx

            # 4. Processa a resposta do n8n de forma simplificada e segura
            try:
                data = resp.json()
                # Acessa a chave "resposta" de forma segura com .get()
                # Se a chave n√£o existir, retorna None e a mensagem de erro √© acionada
                resposta = data.get("resposta")
                if resposta:
                    return resposta
                return f"ü§∑ Resposta recebida, mas em formato inesperado: {json.dumps(data)[:500]}"

            except ValueError: # Ocorre se a resposta n√£o for um JSON v√°lido
                return f"‚ùå Erro de decodifica√ß√£o: A resposta do n8n n√£o √© um JSON v√°lido. Resposta recebida: {resp.text[:400]}"

        except requests.exceptions.ConnectionError:
            return "üö´ Erro de conex√£o com o n8n. Verifique se o endere√ßo do webhook est√° correto e se o n8n est√° em execu√ß√£o."
        except requests.exceptions.Timeout:
            return "‚è±Ô∏è Tempo de espera excedido. O n8n demorou muito para responder (mais de 60 segundos)."
        except requests.exceptions.HTTPError as e:
            # Tenta extrair o corpo da resposta de erro para mais detalhes
            body = e.response.text if e.response else "Nenhum detalhe adicional."
            return f"‚ùå Erro HTTP {e.response.status_code}: {e} - {body[:800]}"
        except Exception as e:
            # Captura qualquer outro erro inesperado
            return f"‚ö†Ô∏è Um erro inesperado ocorreu: {type(e).__name__}: {e}"

    # ======= Sess√£o de mensagens =======
    if "messages" not in st.session_state:
        st.session_state.messages = []

    st.markdown("### üí¨ Conversa")

    chat_container = st.container()
    with chat_container:
        st.markdown('<div class="chat-container">', unsafe_allow_html=True)
        for msg in st.session_state.messages:
            role_class = "chat-user" if msg["role"] == "user" else "chat-bot"
            st.markdown(
                f'<div class="chat-message {role_class}">{msg["content"]}</div>',
                unsafe_allow_html=True,
            )
        st.markdown("</div>", unsafe_allow_html=True)

    # ======= Entrada do usu√°rio =======
    user_query = st.chat_input("Digite sua pergunta aqui...")

    if user_query:
        st.session_state.messages.append({"role": "user", "content": user_query})
        with st.spinner("üí≠ Pensando..."):
            response = ask_chatbot(user_query, uploaded_file=uploaded_file)
        st.session_state.messages.append({"role": "assistant", "content": response})
        st.rerun()

    # ======= Rodap√© =======
    st.divider()
    st.info(f"üåê Chat conectado ao n8n: `{N8N_WEBHOOK_URL}`")
    st.caption("üß† Desenvolvido com n8n + Streamlit + Gemini 2.5 Flash")
    st.caption(datetime.now().strftime("√öltima atualiza√ß√£o: %d/%m/%Y %H:%M"))
# ==========================



    # Tab 4: ML
with aba4:
    st.subheader("üëæ‚ö° Previs√£o de Vendas com Machine Learning")

    # Features e alvo
    X = df[['Estoque', 'Preco_kg']]
    y = df['Vendidos']

    # Split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Modelo
    model = LinearRegression()
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)

    # M√©tricas
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))

    # Layout com 2 colunas
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("#### üìä Desempenho do Modelo")
        st.metric("R¬≤ (Acur√°cia)", f"{r2:.2f}", help=f"Indica que o modelo explica {r2:.0%} da varia√ß√£o nas vendas.")
        st.metric("RMSE (Erro M√©dio)", f"{rmse:.2f}", help=f"Previs√µes erram, em m√©dia, {rmse:.0f} unidades.")
        
        st.markdown("#### üìå Impacto nas Vendas")
        st.write(f"**+1 unidade no estoque** ‚Üí vendas aumentam em m√©dia ~{model.coef_[0]:.1f} unidades")
        st.write(f"**+R$1 no pre√ßo/kg** ‚Üí vendas diminuem em m√©dia ~{abs(model.coef_[1]):.1f} unidades")

    with col2:
        st.markdown("#### üîç Previs√µes vs. Reais")
        import matplotlib.pyplot as plt  # garante que plt foi importado
        fig, ax = plt.subplots()
        ax.scatter(y_test, y_pred, alpha=0.7, s=60)
        ax.plot([0, y_test.max()], [0, y_test.max()], color="red", linestyle="--")
        ax.set_xlabel("Vendas Reais")
        ax.set_ylabel("Vendas Previstas")
        ax.set_title("Vendas Reais vs. Previstas")
        st.pyplot(fig)

    # -----------------------------
    st.markdown("---")
    st.subheader("üîÆ Prever Vendas")

    estoque = st.number_input("üì¶ Estoque dispon√≠vel", min_value=0, value=100, step=10)
    preco = st.number_input("üí∞ Pre√ßo por kg (R$)", min_value=0.0, value=10.0, step=0.5, format="%.2f")
    
    if st.button("Prever", type="primary"):
        pred = max(0, model.predict([[estoque, preco]])[0])
        st.success(f"‚úÖ Previs√£o de vendas: **{pred:.0f} unidades**")
        st.info(f"Com um estoque de {estoque} unidades e pre√ßo de R${preco:.2f}/kg")
        





# ==========================
# üìãüìå ABA 5 - RELAT√ìRIO AUTOM√ÅTICO (GERA E ABRE LOCAL)
# ==========================
with aba5:
    st.subheader("üìãüìå Gera√ß√£o de Relat√≥rio Autom√°tico com YData-Profiling")
    st.write("Fa√ßa o upload de um arquivo (CSV ou Excel) para gerar e abrir um relat√≥rio completo de an√°lise explorat√≥ria.")

    uploaded_file = st.file_uploader(
        "Escolha um arquivo CSV ou Excel", 
        type=['csv', 'xlsx'],
        key="profiling_uploader"
    )

    if uploaded_file is not None:
        try:
            with st.spinner("üìÇ Carregando dados..."):
                if uploaded_file.name.endswith('.csv'):
                    df = pd.read_csv(uploaded_file)
                else:
                    df = pd.read_excel(uploaded_file)

            st.success("‚úÖ Dados carregados com sucesso! Gerando relat√≥rio...")

            # Caminho do arquivo local
            report_path = "profiling_report.html"

            with st.spinner("üîç Analisando o conjunto de dados... Isso pode levar alguns segundos."):
                profile = ProfileReport(df, title="Relat√≥rio de An√°lise Explorat√≥ria", explorative=True)
                profile.to_file(report_path)

            st.success("‚úÖ Relat√≥rio gerado com sucesso!")
            st.markdown(f"O relat√≥rio foi salvo em: `{report_path}`")

            # Bot√£o para abrir o relat√≥rio automaticamente no navegador local
            if st.button("üåê Abrir relat√≥rio no navegador"):
                webbrowser.open_new_tab(f"file://{os.path.abspath(report_path)}")
                st.info("O relat√≥rio foi aberto em uma nova aba do seu navegador.")

        except Exception as e:
            st.error(f"‚ùå Ocorreu um erro ao processar o arquivo: {e}")

    else:
        st.info("Aguardando o upload de um arquivo para come√ßar a an√°lise.")




# ==========================
# Tab 6: Sobre o Projeto Agro
# ==========================
with aba6:
    st.subheader("üìö Sobre o Projeto Agro")
    st.markdown("""
    Bem-vindo ao Dashboard Agro! Este projeto foi desenvolvido para fornecer insights valiosos sobre vendas agr√≠colas, utilizando an√°lise de dados, visualiza√ß√µes interativas e modelos de machine learning.

    ### Objetivos do Projeto
    - Analisar dados de vendas agr√≠colas para identificar tend√™ncias e padr√µes.
    - Fornecer ferramentas interativas para explorar os dados.
    - Implementar um chatbot inteligente para responder perguntas sobre os dados.
    - Utilizar machine learning para prever vendas futuras com base em vari√°veis-chave.

    ### Tecnologias Utilizadas
    - **Streamlit**: Framework principal para constru√ß√£o do dashboard.
    - **Pandas & NumPy**: Manipula√ß√£o e an√°lise de dados.
    - **Plotly & Matplotlib**: Visualiza√ß√µes interativas e est√°ticas.
    - **Scikit-learn**: Modelagem preditiva com machine learning.
    - **n8n**: Automa√ß√£o de workflows e integra√ß√£o do chatbot.

    ### Equipe de Desenvolvimento
    - Desenvolvedor 1: [Lu√≠s Filipe Moreira Novais]
    - Analista de Dados: [Lu√≠s Filipe Moreira Novais]

    ### Contato
    Para d√∫vidas, sugest√µes ou colabora√ß√µes, entre em contato atrav√©s do email: luisfilipemnovais@gmail.com
    """)
    st.subheader("üõ†Ô∏è Ferramentas Futuras")
    st.markdown("""
    - üìä An√°lises avan√ßadas com mais gr√°ficos interativos
    - ü§ñ Chatbot aprimorado com mais funcionalidades
    - üß† Modelos de ML adicionais para diferentes previs√µes
    - üåê Integra√ß√£o com APIs externas para dados em tempo real
    - üì• Op√ß√µes de exporta√ß√£o adicionais (PDF, CSV)
    - üîí Seguran√ßa e autentica√ß√£o de usu√°rios
    """)
    st.info("üöß Esta se√ß√£o est√° em desenvolvimento. Fique atento para futuras atualiza√ß√µes!")